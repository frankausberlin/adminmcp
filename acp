#!/usr/bin/env python3

# -*- coding: utf-8 -*-
#
# FILENAME: acp
# LOCATION: ~/bin/
# PURPOSE:  Execute a shell command, log all details (time, exit code, stdout, stderr,
#           user info, parent process ID) to a JSON file in /tmp, print the output,
#           and relay the original exit code.
#           Can also be used to view and filter existing logs (--log).

import subprocess
import sys
import time
import os
import json
import argparse
from datetime import datetime
import glob 

# --- CONFIGURATION ---
# Maximum number of log files to keep in the directory (for cleanup)
MAX_LOG_FILES = 1000

# ANSI Escape Codes for Colors
GRAY = '\033[2m'
LIGHT_GRAY = '\033[37m'
RED = '\033[31m'
GREEN = '\033[32m'
YELLOW = '\033[33m'
CYAN = '\033[36m'
BOLD = '\033[1m'
RESET = '\033[0m'

# --- HELPER FUNCTIONS ---

def get_log_dir():
    """Returns the log directory path."""
    return os.path.join(os.environ.get('TMPDIR', os.environ.get('TEMP', '/tmp')), 'bash_session_logs')

def cleanup_old_logs(log_dir):
    """
    Deletes the oldest log files if the number of files exceeds the maximum.
    """
    search_pattern = os.path.join(log_dir, '*_shellexecute.json')
    log_files = glob.glob(search_pattern)
    
    # Sort files by modification time (oldest first)
    log_files.sort(key=os.path.getmtime)
    
    if len(log_files) > MAX_LOG_FILES:
        files_to_delete = log_files[:len(log_files) - MAX_LOG_FILES]
        
        for filepath in files_to_delete:
            try:
                os.remove(filepath)
            except OSError as e:
                sys.stderr.write(f"{RED}ERROR: Could not delete old log file {filepath}. Reason: {e}{RESET}\n")

# --- MODE 1: EXECUTE COMMAND AND LOG ---

def log_shell_command(command_list, quiet=False, timeout=7200):
    """
    Executes a shell command, measures time, logs all details into a JSON file,
    and prints the command's original output (stdout/stderr) to the console.
    It returns the command's exit code.
    """
    log_dir = get_log_dir()
    os.makedirs(log_dir, exist_ok=True) # Ensure the directory exists

    # 1. Output logging activation message in gray (unless quiet)
    if not quiet:
        sys.stdout.write(f"{GRAY}>> Logging active in {log_dir} <<{RESET}\n")
        sys.stdout.flush()
    
    start_time = time.time()
    
    try:
        # Execute the command and capture output
        result = subprocess.run(
            command_list,
            capture_output=True,
            text=True,
            encoding='utf-8', # Explicit encoding for clarity
            check=False,
            timeout=timeout
        )
        
        end_time = time.time()
        
        # Collect details
        exit_code = result.returncode
        stdout_data = result.stdout
        stderr_data = result.stderr
        duration = end_time - start_time
        command_line = " ".join(command_list)

    except FileNotFoundError:
        end_time = time.time()
        exit_code = 127
        stdout_data = ""
        stderr_data = f"ERROR: Command not found: {command_list[0]}\n" 
        duration = end_time - start_time
        command_line = " ".join(command_list)
        
    except subprocess.TimeoutExpired:
        end_time = time.time()
        exit_code = 124
        stdout_data = ""
        stderr_data = f"ERROR: Command timed out after {timeout} seconds.\n"
        duration = end_time - start_time
        command_line = " ".join(command_list)

    # 2. Console Output of captured STDOUT/STDERR
    if stdout_data:
        sys.stdout.write(stdout_data)

    if stderr_data:
        sys.stderr.write(f"{RED}{stderr_data}{RESET}")
        
    # --- Collecting Enhanced Metadata ---
    username = os.environ.get('USER') or os.environ.get('USERNAME') or 'unknown_user'
    parent_pid = os.getppid()

    # 3. Create the log data object (JSON structure)
    log_data = {
        "execution_timestamp_iso": datetime.now().isoformat(),
        "execution_duration_seconds": round(duration, 4),
        "command_line": command_line,
        "exit_code": exit_code,
        "metadata": { 
            "user": username,
            "parent_pid": parent_pid,
            "host": os.uname().nodename if hasattr(os, 'uname') else 'unknown_host'
        },
        "stdout": stdout_data.strip(),
        "stderr": stderr_data.strip()
    }
    
    # 4. Create log file path
    timestamp_str = datetime.now().strftime('%Y%m%d%H%M%S%f')[:-3]
    filename = f"{timestamp_str}_shellexecute.json"
    filepath = os.path.join(log_dir, filename)
    
    # 5. Write content to the JSON file
    try:
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=4) 
    except Exception as e:
        sys.stderr.write(f"{RED}ERROR: Could not write log file {filepath}. Reason: {e}{RESET}\n")
    
    # 6. Clean up old log files
    cleanup_old_logs(log_dir)

    # 7. Return the command's exit code
    return exit_code

# --- MODE 2: VIEW LOGS ---

def load_and_filter_logs(args):
    """Loads all logs, applies filters, and returns them sorted."""
    log_dir = get_log_dir()
    search_pattern = os.path.join(log_dir, '*_shellexecute.json')
    log_files = glob.glob(search_pattern)
    
    if not log_files:
        print(f"{YELLOW}No log files found in directory: {log_dir}{RESET}")
        return []

    # 1. Sort files by modification time (newest first)
    log_files.sort(key=os.path.getmtime, reverse=True)
    
    loaded_logs = []
    
    for filepath in log_files:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                log_data = json.load(f)
                
                # Add the filename for potential later reference
                log_data['log_filename'] = os.path.basename(filepath) 
                
                # 2. Apply PID filter
                if args.filter_pid is not None:
                    if log_data.get('metadata', {}).get('parent_pid') != args.filter_pid:
                        continue # Skip if PID does not match

                loaded_logs.append(log_data)
        except Exception as e:
            sys.stderr.write(f"{RED}ERROR loading {filepath}: {e}{RESET}\n")
    
    # 3. Apply 'Last N' filter
    if args.last is not None and args.last > 0:
        return loaded_logs[:args.last]
        
    return loaded_logs

def format_log_entry(log_data, short_mode=False):
    """Formats a single log entry for console output."""
    
    # Color scheme based on Exit Code
    exit_code = log_data.get('exit_code', -1)
    exit_color = GREEN if exit_code == 0 else RED

    # Metadata
    timestamp = log_data.get('execution_timestamp_iso', 'N/A').split('.')[0].replace('T', ' ')
    duration = log_data.get('execution_duration_seconds', 0)
    
    user = log_data.get('metadata', {}).get('user', 'unknown')
    pid = log_data.get('metadata', {}).get('parent_pid', 'N/A')
    
    command = log_data.get('command_line', 'N/A')

    output = []

    # Short View
    if short_mode:
        output.append(
            f"{BOLD}{CYAN}[{timestamp}]{RESET} "
            f"PID:{pid} | "
            f"User:{user} | "
            f"Duration:{round(duration, 3)}s | "
            f"Exit:{exit_color}{exit_code}{RESET} | "
            f"{BOLD}{command}{RESET}"
        )
    # Full View
    else:
        # Header
        output.append("\n" + "=" * 80)
        output.append(f"{BOLD}Log File:{RESET} {log_data.get('log_filename', 'N/A')}")
        output.append(f"{BOLD}Timestamp:{RESET} {CYAN}{timestamp}{RESET} | {BOLD}Duration:{RESET} {round(duration, 3)}s | {BOLD}Exit Code:{RESET} {exit_color}{exit_code}{RESET}")
        output.append(f"{BOLD}User:{RESET} {user} | {BOLD}PID (Session):{RESET} {pid} | {BOLD}Host:{RESET} {log_data.get('metadata', {}).get('host', 'N/A')}")
        output.append("-" * 80)
        output.append(f"{BOLD}Command Line:{RESET} {YELLOW}{command}{RESET}")
        
        # STDOUT
        stdout = log_data.get('stdout')
        if stdout:
            output.append(f"\n{BOLD}STDOUT:{RESET}")
            output.append(f"{LIGHT_GRAY}{stdout}{RESET}")
            
        # STDERR
        stderr = log_data.get('stderr')
        if stderr:
            output.append(f"\n{BOLD}STDERR:{RESET}")
            output.append(f"{RED}{stderr}{RESET}")
        
        output.append("\n" + "=" * 80)

    return "\n".join(output)

def list_logs(args):
    """Main function for the log viewing mode."""
    logs = load_and_filter_logs(args)
    
    if not logs:
        # Error message already handled in load_and_filter_logs
        return

    print(f"\n{BOLD}--- DISPLAYING {len(logs)} LOGS ({'Short View' if args.short else 'Full View'}) ---{RESET}")
    for log in logs:
        print(format_log_entry(log, args.short))
    
    if not args.short:
         print(f"{BOLD}--- END OF LOGS ---{RESET}")


# --- MAIN PROGRAM ---

def main():
    parser = argparse.ArgumentParser(description="A versatile shell command wrapper for execution or viewing logs.")
    
    # Arguments for Execution Mode
    parser.add_argument('-q', '--quiet', action='store_true', help='Quiet mode: suppress logging activation message (Execution Mode only).')
    parser.add_argument('-t', '--timeout', type=int, default=7200, help='Timeout in seconds (default: 7200) (Execution Mode only).')

    # Arguments for Log Viewing Mode
    parser.add_argument('--log', action='store_true', help='Activates log viewing mode instead of command execution.')
    parser.add_argument('--short', action='store_true', help='Shows a brief summary per log entry (Log Viewing Mode only).')
    parser.add_argument('-n', '--last', type=int, default=None, help='Shows the last N log entries (Log Viewing Mode only).')
    parser.add_argument('-p', '--filter-pid', type=int, default=None, help='Filters logs by the Parent Process ID (PID) (Log Viewing Mode only).')
    
    # Command to execute (variable/optional)
    parser.add_argument('command', nargs='*', help='The command to execute (Ignored if --log is used).')

    args = parser.parse_args()

    # Logic: Check if log viewing mode is active
    if args.log:
        list_logs(args)
        sys.exit(0)
    
    # Logic: Check if a command was provided for execution
    elif not args.command:
        # If neither --log nor a command was provided, show help
        parser.print_help()
        sys.exit(1)
    
    # Logic: Standard execution mode
    else:
        # Executes the logging function and sets the Python script's exit code
        exit_code = log_shell_command(args.command, quiet=args.quiet, timeout=args.timeout)
        sys.exit(exit_code)

if __name__ == '__main__':
    # Allow argument initialization without calling main() if the script is imported (e.g., for testing),
    # but execute main() if run directly.
    try:
        main()
    except SystemExit:
        pass # Ignore SystemExit (from sys.exit) as it is standard argparse behavior